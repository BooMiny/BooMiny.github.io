<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SexMonkey</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="女程序猿也可以性感和可耐o(*￣▽￣*)ブ">
<meta property="og:type" content="website">
<meta property="og:title" content="SexMonkey">
<meta property="og:url" content="http://boominy.github.io/index.html">
<meta property="og:site_name" content="SexMonkey">
<meta property="og:description" content="女程序猿也可以性感和可耐o(*￣▽￣*)ブ">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SexMonkey">
<meta name="twitter:description" content="女程序猿也可以性感和可耐o(*￣▽￣*)ブ">
  
    <link rel="alternate" href="/atom.xml" title="SexMonkey" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

    
    <script src="https://leancloud.cn/scripts/lib/av-0.4.6.min.js"></script>
  <script>AV.initialize("7jLaPEaNjAdu9N26yLk8sdyf-gzGzoHsz", "0qQ0z6bI5p5dnwgK9Aqxx0a6");</script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="/images/haimian.jpg">
    <h2 class="author">BooMiny</h2>
    <h3 class="description">女程序猿也可以性感和可耐o(*￣▽￣*)ブ</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>25</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-javafile" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/05/javafile/" class="article-date">
  <time class="post-time" datetime="2017-07-05T09:52:19.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/javafile/">java读写文件</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/07/05/javafile/" class="leancloud_visitors" data-flag-title="java读写文件">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​      java读写文件的方法挺多的，在初学java的时候更是傻傻分不清，在搜集各路大神的资料后，我总结了一个较为完善的版本。</p>
<h3 id="一、文件IO图"><a href="#一、文件IO图" class="headerlink" title="一、文件IO图"></a>一、文件IO图</h3><p><img src="/2017/07/05/javafile/dada.png" alt="Alt dd"></p>
<h3 id="二、相关的类和流"><a href="#二、相关的类和流" class="headerlink" title="二、相关的类和流"></a>二、相关的类和流</h3><ol>
<li><p><strong>File类</strong>：</p>
<ul>
<li>File类封装了<strong>对用户机器的文件系统进行操作</strong>的功能。例如，可以用File类获得文件上次修改的时间移动，或者对文件进行删除、重命名。</li>
<li>File类的主要方法有：<strong>getName()</strong>,getCanonicalFile(),lastModified(),<strong>isDerector()</strong>,<strong>isFile()</strong>,getPath()</li>
<li>②File类与FileInputStream类的区别： </li>
<li><strong>流类关注</strong>的是<strong>文件内容</strong>，而<strong>File类</strong>关注的是<strong>文件在磁盘上的存储</strong>。</li>
<li>File不属于文件流,<strong>只能代表</strong>一个文件或是目录的<strong>路径名</strong>而已。</li>
<li>如果<strong>处理文件或者目录名</strong>，就应该<strong>使用File对象</strong>，而不是字符串。例如，File类的equals方法知道一些文件系统对大小写是敏感的，目录尾的“/”字符无关紧要。</li>
<li>自己的领会： FileInputStream类或者FileReader类的构造函数有多个，其中典型的两个分别为：一个使用File对象为参数；而另一个使用表示路径的String对象作为参数；自己以前一直觉得直接用了String指定路径就可以了，一直不明白为什么很多人都先构造一个File对象，现在终于明白了，“<strong>如果处理文件或者目录名，就应该使用File对象，而不是字符串。</strong>”！ </li>
</ul>
</li>
<li><p><strong>FileInputStream类</strong>：</p>
<ul>
<li><p>①FileInputStream类介绍：</p>
</li>
<li><p>以<strong>字节为单位</strong>（非unicode）的流处理。字节序列即：<strong>二进制数据</strong>。与编码无关，不存在乱码问题。</p>
</li>
<li><p>FileInputStream类的主要方法有： <strong>Read（）</strong>，<strong>read（byte[] b）</strong>，<strong>read（byte[],int off,int len）</strong>,available();</p>
</li>
<li><p>②FileInputStream类与FileReader类的区别： </p>
<p>两个类的<strong>构造函数的形式和参数都是相同</strong>的，<strong>参数为File对象或者表示路径的String</strong>，它们到底有何区别呢？</p>
<p><strong>FileInputStream</strong>：<strong>以字节流方式读取</strong>；</p>
<p><strong>FileReader：把文件转换为字符流读</strong></p>
<p><strong>InputStream提供的是字节流的读取，而非文本读取</strong>，这是和Reader类的根别。用<strong>Reader读取出来的是char数组或者String</strong> ，使用<strong>InputStream读取出来的是byte数组</strong>。</p>
<p><strong>Reader类及其子类提供的字符流的读取char（16位,unicode编码）</strong>，<strong>inputStream及其子类提供字节流的读取byte（8位）</strong>，所以<strong>FileReader类</strong>是将文件按<strong>字符流</strong>的方式读取，<strong>FileInputStream</strong>则按<strong>字节流</strong>的方式读取文件；<strong>InputStreamReader可以将读如stream转换成字符流方式</strong>，<strong>是reader和stream之间的桥梁 </strong></p>
<p>最初<a href="http://lib.csdn.net/base/java" target="_blank" rel="external">Java</a>是不支持对文本文件的处理的，为了弥补这个缺憾而引入了Reader和Writer两个类。 </p>
<p>FileInputStream类以二进制输入/输出，I/O速度快且效率搞，但是它的read（）方法读到的是一个字节（二进制数据），很不利于人们阅读。 </p>
<p>而FileReader类弥补了这个缺陷，可以以文本格式输入/输出，非常方便；比如可以使用<strong>while((ch = filereader.read())!=-1 )循环来读取文件</strong>；可以使用<strong>BufferedReader的readLine()方法一行一行的读取文本</strong>。 </p>
<p>当我们<strong>读写文本文件</strong>的时候，<strong>采用Reader</strong>是非常方便的，比如FileReader， InputStreamReader和BufferedReader。其中<strong>最重要的类是InputStreamReader</strong>，它是字节转换为字符的桥梁。 你<strong>可以在构造器重指定编码的方式</strong>，如果<strong>不指定的话将采用底层<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>的默认编码方式</strong>，例如GBK等。 </p>
<p><strong>FileReader与InputStreamReader涉及编码转换(指定编码方式或者采用os默认编码)</strong>，<strong>可能</strong>在不同的平台上出现<strong>乱码</strong>现象！而<strong>FileInputStream以二进制方式处理</strong>，<strong>不会出现乱码</strong>现象. </p>
<p>自己的领会： </p>
<p><strong>如果处理纯文本文件，建议使用FileReader</strong>，因为更方便，也更适合阅读；但是要注意编码问题！ </p>
<p><strong>其他情况（处理非纯文本文件），FileInputStream是唯一的选择</strong>；FileInputStream是进Socket通讯时会用到很多，如将文件流是Stream的方式传向服务器！</p>
</li>
</ul>
</li>
<li><p><strong>FileReader类</strong>： </p>
<p><strong>InputStreamReader类的子类</strong>，所有方法（read（）等）都从父类InputStreamReader中继承而来； </p>
<p>② 与InputStreamReader类的区别：</p>
<p>参见上面的区别;</p>
<p>自己的领会： </p>
<p>该类与它的父类InputStreamReader的<strong>主要不同在于构造函数</strong>，主要区别也就在于构造函数！从InputStreamReader的构造函数中看到，参数为<strong>InputStream和编码方式，可以看出，当要指定编码方式时，必须使用InputStreamReader类</strong>；而FileReader构造函数的参数与FileInputStream同，为File对象或表示path的String，可以看出，当要根据File对象或者String读取一个文件时，用FileReader；我想FileReader子类的作用也就在于这个小分工吧。</p>
</li>
</ol>
<p>   一般用法： </p>
<p>   FileReader fr = new FileReader(“ming.txt”); </p>
<p>   　　 char[] buffer = new char[1024]; </p>
<p>   　　 int ch = 0; </p>
<p>   　　while((ch = fr.read())!=-1 ) </p>
<p>   　　{ </p>
<p>   　　　System.out.print((char)ch); </p>
<p>   　　} </p>
<ol>
<li><p><strong>InputStreamReader类</strong>： </p>
<p>以文本格式输入/输出，可以指定编码格式； </p>
<p>主要方法： getEncoding()，read(); </p>
<p>一般用法： </p>
<p>InputStreamReader isr = new InputStreamReader(new FileInputStream(“ming.txt”)); </p>
<p>　　while((ch = isr.read())!=-1) </p>
<p>　　{ </p>
<p>　　　System.out.print((char)ch); </p>
<p>　　} </p>
</li>
<li><p>BufferedReader类 </p>
<p>BufferedReader 由Reader类扩展而来，提供通用的缓冲方式文本读取，而且提供了很实用的readLine，读取分行文本很适合，BufferedReader是针对Reader的，不直接针对文件，也不是只针对文件读取。 </p>
<p>一般用法： </p>
<p>BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(“ming.txt”))); </p>
<p>　　 String data = null; </p>
<p>　　 while((data = br.readLine())!=null) </p>
<p>　　 { </p>
<p>　　　 System.out.println(data); </p>
<p>　　 } </p>
</li>
<li><p>总结以上内容，得出比较好的规范用法： </p>
<p>① </p>
<p>File file = new File (“hello.txt”); </p>
<p>FileInputStream in=new FileInputStream(file); </p>
<p>② </p>
<p>File file = new File (“hello.txt”); </p>
<p>FileInputStream in=new FileInputStream(file); </p>
<p>InputStreamReader inReader=new InputStreamReader(in); </p>
<p>BufferedReader bufReader=new BufferedReader(inReader); </p>
<p>③ </p>
<p>File file = new File (“hello.txt”); </p>
<p>FileReader fileReader=new FileReader(file); </p>
<p>BufferedReader bufReader=new BufferedReader(fileReader);</p>
</li>
<li><p>FileWriter类：</p>
<p>构造方法：FileWriter fw = new FileWriter(String fileName);//创建字符输出流类对象和已存在的文件相关联。文件不存在的话，并创建。</p>
<p>​                                             如：FileWriter fw = new FileWriter(“C:\demo.txt”);</p>
<p>​                  FileWriter fw = new FileWriter(String fileName,boolean append);//创建字符输出流类对象和已存在的文件相关联,并设置该该流对文件的操作是否为续写。</p>
<p>​                                             如：FileWriter fw = new FileWriter(“C:\demo.txt”,ture); //表示在fw对文件再次写入时，会在该文件的结尾续写，并不会覆盖掉。</p>
<p>主要方法： void write(String str)   //写入字符串。当执行完此方法后，字符数据还并没有写入到目的文件中去。此时字符数据会保存在缓冲区中。</p>
<p>​                                                        此时在使用刷新方法就可以使数据保存到目的文件中去。</p>
<p>​                  viod flush()                //刷新该流中的缓冲。将缓冲区中的字符数据保存到目的文件中去。</p>
<p>​                  viod close()               //关闭此流。在关闭前会先刷新此流的缓冲区。在关闭后，再写入或者刷新的话，会抛IOException异常</p>
<p>package filewriter;  </p>
</li>
</ol>
<p>   import java.io.FileWriter;  </p>
<p>   import java.io.IOException;  </p>
<p>   public class Filewriter {  </p>
<p>   ​    private static final String LINE_SEPARATOR = System.getProperty(“line.separator”);  </p>
<pre><code>/** 
</code></pre><p>   ​     *  </p>
<p>   ​     * @param args </p>
<p>   ​     * @throws IOException  </p>
<p>   ​     */  </p>
<p>   ​    public static void main(String[] args) throws IOException {  </p>
<p>   ​        /** </p>
<p>   ​         * 创建一个可以往文件中写入字符数据的字符流输出流对象 </p>
<p>   ​         * 创建时必须明确文件的目的地 </p>
<p>   ​         * 如果文件不存在，这回自动创建。如果文件存在，则会覆盖。 </p>
<p>   ​         * 当路径错误时会抛异常 </p>
<p>   ​         *  </p>
<p>   ​         * 当在创建时加入true参数，回实现对文件的续写。 </p>
<p>   ​         */  </p>
<p>   ​        FileWriter fw = new FileWriter(“C:\demo1.txt”,false);  </p>
<p>   ​        /** </p>
<p>   ​         * 调用该对象的write方法，向文件写入字符。 </p>
<p>   ​         *  </p>
<p>   ​         * 其实写入到了临时存储缓冲区中 </p>
<p>   ​         */  </p>
<p>   //      fw.write(“hello \r\nworld!”);//windows中的换行为\r\n    unix下为\r。  </p>
<p>   ​        fw.write(“aello”+LINE_SEPARATOR+”world!”);          fw.write(“hahaha”);  </p>
<p>   ​       /** </p>
<p>   ​         * 进行刷新，将字符写到目的地中。 </p>
<p>   ​         */  </p>
<p>   //      fw.flush();  </p>
<p>   ​        /** </p>
<p>   ​         * 关闭流，关闭资源。在关闭前会调用flush方法 刷新缓冲区。关闭后在写的话，会抛IOException </p>
<p>   ​         */          fw.close();  </p>
<p>   ​            </p>
<p>   ​    }  </p>
<p>   }  </p>
<ol>
<li>实例：</li>
</ol>
<p>import java.io.FileInputStream;  </p>
<p>import java.io.FileOutputStream;  </p>
<p>import java.io.IOException;  </p>
<p>class IODemo  </p>
<p>{  </p>
<p>​    public static void main(String[] args)   </p>
<p>​    {  </p>
<p>​        try  </p>
<p>​        {  </p>
<p>​        //使用FileInputStream和FileOutputStream进行文件复制  </p>
<p>​        FileInputStream fis=new FileInputStream(“a.txt”);  </p>
<p>​        FileOutputStream fos=new FileOutputStream(“b.txt”);  </p>
<p>​            int read;  </p>
<p>​            //read=fis.read();  </p>
<p>​            byte b[]=new byte[1024];  </p>
<p>​            //读取文件，存入字节数组b，返回读取到的字符数，存入read,默认每次将b数组装满  </p>
<p>​            read=fis.read(b);  </p>
<p>​            while(read!=-1)  </p>
<p>​            {  </p>
<p>​                fos.write(b,0,read);  </p>
<p>​                read=fis.read(b);  </p>
<p>​                //read=fis.read();  </p>
<p>​           }  </p>
<p>​            fis.close();  </p>
<p>​            fos.close();  </p>
<p>​        }  </p>
<p>​        catch (IOException e)  </p>
<p>​        {  </p>
<p>​           e.printStackTrace();  </p>
<p>​        }  </p>
<p>​          </p>
<p>​    }  </p>
<p>}  </p>
<p>9.用FileReader  和 FileWriter 写的复制文本文件的小程序。</p>
<p>package IOtest;    </p>
<p>import java.io.FileNotFoundException;  </p>
<p>import java.io.FileReader;  </p>
<p>import java.io.FileWriter;  </p>
<p>import java.io.IOException;  </p>
<p>public class TxtCopy {  </p>
<p>​    /** </p>
<p>​     * 将C：\的myHeart.txt copy 到 D:\下 </p>
<p>​     *  </p>
<p>​     * 首先创建Reader读取数据数据的 读取流对象。 </p>
<p>​     *  </p>
<p>​     * @throws FileNotFoundException </p>
<p>​     */  </p>
<p>​    public static void main(String[] args) {  </p>
<p>​        FileReader fr = null;  </p>
<p>​        FileWriter fw = null;  </p>
<p>​        try {  </p>
<p>​            fr = new FileReader(“C:\my.txt”);  </p>
<p>​            fw = new FileWriter(“D:\you.txt”);  </p>
<p>​            //读一个字符，写一个字符方法  </p>
<p>//          int ch = 0;  </p>
<p>//  </p>
<p>//          while ((ch = fr.read()) != -1) {  </p>
<p>//              fw.write(ch);  </p>
<p>//          }  </p>
<p>​            char []buf = new char[1024];  </p>
<p>​            int len = 0;  </p>
<p>​           //读一个数组大小，写一个数组大小方法。  </p>
<p>​            while((len = fr.read(buf)) != -1){  </p>
<p>​                fw.write(buf, 0, len);                </p>
<p>​            }  </p>
<p>​              </p>
<p>​        } catch (Exception e) {  </p>
<p>​            System.out.println(e.toString());  </p>
<p>​        } finally {  </p>
<p>​            if (fr != null)  </p>
<p>​                try {  </p>
<p>​                    fr.close();  </p>
<p>​                } catch (Exception e2) {  </p>
<p>​                    throw new RuntimeException(“关闭失败！”);  </p>
<p>​                }  </p>
<p>​            if (fw != null)                  try {  </p>
<p>​                    fw.close();                  } catch (IOException e) {  </p>
<p>​                    throw new RuntimeException(“关闭失败！”);  </p>
<p>​                }  </p>
<p>​        }  </p>
<p>​    }  </p>
<p>}  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/07/05/javafile/" data-id="cj4r0q9cv000arotpcapd0ukv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-TCP-Ip" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/05/TCP-Ip/" class="article-date">
  <time class="post-time" datetime="2017-07-05T02:56:20.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/TCP-Ip/">TCP/IP协议</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/07/05/TCP-Ip/" class="leancloud_visitors" data-flag-title="TCP/IP协议">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、定义："><a href="#一、定义：" class="headerlink" title="一、定义："></a>一、定义：</h3><p>TCP/IP 是供已连接因特网的计算机进行通信的通信协议。</p>
<p>TCP/IP 指传输控制协议/网际协议 (<em>T</em>ransmission <em>C</em>ontrol <em>P</em>rotocol / <em>I</em>nternet <em>P</em>rotocol)。</p>
<p>TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。</p>
<h4 id="二、TCP-IP中包含一系列用于处理数据的通信协议："><a href="#二、TCP-IP中包含一系列用于处理数据的通信协议：" class="headerlink" title="二、TCP/IP中包含一系列用于处理数据的通信协议："></a>二、TCP/IP中包含一系列用于处理数据的通信协议：</h4><ul>
<li><p>TCP (传输控制协议) - 应用程序之间通信</p>
<ul>
<li>固定连接的</li>
</ul>
</li>
</ul>
<ul>
<li><p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个<strong>全双工 (full-duplex) 的通信</strong>。</p>
<p>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p>
<p>UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。</p>
</li>
</ul>
<ul>
<li><p>UDP (用户数据包协议) - 应用程序之间的简单通信</p>
</li>
<li><p>IP (网际协议) - 计算机之间的通信</p>
<ul>
<li><p>当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。</p>
<p>IP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。</p>
<p>在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。</p>
</li>
</ul>
</li>
<li><p>ICMP (因特网消息控制协议) - 针对错误和状态</p>
</li>
<li><p>DHCP (动态主机配置协议) - 针对动态寻址</p>
</li>
<li><p>TCP/IP 意味着 TCP 和 IP 在一起协同工作。</p>
<p>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。</p>
<p>IP 负责计算机之间的通信。</p>
<p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。</p>
<p>IP 负责将包发送至接受者。</p>
</li>
</ul>
<h4 id="三、TCP-IP是不同通信协议的大结合"><a href="#三、TCP-IP是不同通信协议的大结合" class="headerlink" title="三、TCP/IP是不同通信协议的大结合"></a>三、TCP/IP是不同通信协议的大结合</h4><ol>
<li><p>TCP - 传输控制协议</p>
<ul>
<li><p>TCP 用于从应用程序到网络的数据传输控制。</p>
<p>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</p>
</li>
</ul>
</li>
<li><p>IP - 网际控制协议</p>
<ul>
<li><p>IP 负责计算机之间的通信。</p>
<p>IP 负责在因特网上发送和接收数据包。</p>
</li>
</ul>
</li>
<li><p>HTTP - 超文本控制协议</p>
<ul>
<li><p>HTTP 负责 web 服务器与 web 浏览器之间的通信。</p>
<p>HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。</p>
</li>
</ul>
</li>
<li><p>HTTPS - 安全的HTTP</p>
<ul>
<li><p>HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。</p>
<p>作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。</p>
</li>
</ul>
</li>
<li><p>SSL -安全套接字</p>
<ul>
<li>SSL 协议用于为安全数据传输加密数据。</li>
</ul>
</li>
<li><p>SMTP  - 简单邮件传输协议</p>
<ul>
<li>SMTP 用于电子邮件的传输。</li>
</ul>
</li>
<li><p>FTP - 文件传输协议</p>
<ul>
<li>FTP 负责计算机之间的文件传输。</li>
</ul>
</li>
<li><p>ICMP  - 因特网消息控制协议</p>
<p>ICMP 负责网络中的错误处理。</p>
</li>
<li><p>PPTP - 点对点隧道协议</p>
<p>PPTP 用于私人网络之间的连接（隧道）。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/07/05/TCP-Ip/" data-id="cj4r0q9cb0004rotpl2x6hkyj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-http" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/03/http/" class="article-date">
  <time class="post-time" datetime="2017-07-03T02:28:02.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">03</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/03/http/">http协议</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/07/03/http/" class="leancloud_visitors" data-flag-title="http协议">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>序言：这个其实就是自己整理的关键信息，没事的时候回顾回顾，详细信息请参照w3c标准。</p>
<h3 id="一：定义："><a href="#一：定义：" class="headerlink" title="一：定义："></a>一：定义：</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）</p>
<h3 id="二、工作原理："><a href="#二、工作原理：" class="headerlink" title="二、工作原理："></a>二、工作原理：</h3><ol>
<li>HTTP协议工作于<strong>客户端-服务端</strong>架构为上。浏览器作为HTTP客户端通过<strong>URL</strong>向HTTP服务端即WEB服务器发送所有请求</li>
<li>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。</li>
<li>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</li>
</ol>
<h3 id="三、特点："><a href="#三、特点：" class="headerlink" title="三、特点："></a>三、特点：</h3><ol>
<li><strong>无连接</strong>：无连接的含义是限制<strong>每次连接只处理一个请求</strong>。服务器<strong>处理</strong>完客户的请求，<strong>并</strong>收到客户的<strong>应答后</strong>，即<strong>断开连接</strong>。采用这种方式可以<strong>节省传输时间</strong>。</li>
<li><strong>媒体独立</strong>的：这意味着，<strong>只要客户端和服务器知道如何处理的数据内容</strong>，任何类型的数据<strong>都可以通过HTTP发送</strong>。客户端以及服务器指定使用适合的MIME-type内容类型。</li>
<li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理<strong>没有记忆能力</strong>。缺少状态意味着如果<strong>后续处理需要前面的信息，则它必须重传</strong>，这样可能<strong>导致每次连接传送的数据量增大</strong>。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
<li>请求</li>
</ol>
<h3 id="三、请求方法"><a href="#三、请求方法" class="headerlink" title="三、请求方法"></a>三、请求方法</h3><table>
<thead>
<tr>
<th>1</th>
<th>GET</th>
<th>请求指定的页面信息，并返回实体主体。</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>HEAD</td>
<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>3</td>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td>请求服务器删除指定的页面。</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
</tbody>
</table>
<h4 id="四、常见状态码"><a href="#四、常见状态码" class="headerlink" title="四、常见状态码"></a>四、常见状态码</h4><ul>
<li>200 - 请求成功</li>
</ul>
<ul>
<li><p>301 - 资源（网页等）被永久转移到其它URL</p>
</li>
<li><p>400 - 客户端请求有语法错误，不能被服务器所理解</p>
</li>
<li><p>401 - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </p>
</li>
<li><p>403 - 服务器收到请求，但是拒绝提供服务</p>
</li>
<li><p>404 - 请求的资源（网页等）不存在</p>
</li>
<li><p>500 - 内部服务器错误</p>
</li>
<li><p>503 Server - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
</li>
<li><p>状态码分类：</p>
<p>| 分类   | 分类描述                    |<br>| —- | ———————– |<br>| 1<strong>  | 信息，服务器收到请求，需要请求者继续执行操作  |<br>| 2</strong>  | 成功，操作被成功接收并处理           |<br>| 3<strong>  | 重定向，需要进一步的操作以完成请求       |<br>| 4</strong>  | 客户端错误，请求包含语法错误或无法完成请求   |<br>| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |</p>
</li>
</ul>
<h3 id="五、HTTP协议相关技术补充"><a href="#五、HTTP协议相关技术补充" class="headerlink" title="五、HTTP协议相关技术补充"></a>五、HTTP协议相关技术补充</h3><ol>
<li><p>基础： 高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等</p>
</li>
<li><p>中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)。</p>
<ul>
<li><strong>一个代理根据URI的绝对格式来接受请求</strong>，<strong>重写全部或部分消息</strong>，通过 URI的标识把已格式化过的请求发送到服务器。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>网关是一个接收代理</strong>，<strong>作为一些其它服务器的上层</strong>，并且如果必须的话，<strong>可以把请求翻译给下层的服务器协议</strong>。</li>
<li><strong>一 个通道作为不改变消息的两个连接之间的<em>中继点</em></strong>。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。</li>
</ul>
<ol>
<li><p>协议分析的优势—HTTP分析器检测网络攻击</p>
<ul>
<li>以<strong>模块化的方式对高层协议进行分析处理</strong>，将是未来入侵检测的方向。<br>HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定</li>
</ul>
</li>
<li><p>、HTTP协议<strong>Content Lenth限制漏洞导致拒绝服务攻击</strong></p>
<ul>
<li>使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，<strong>在传送完成前，内 存不会释放</strong>，攻击者可以利用这个缺陷，<strong>连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽</strong>。这种攻击方法基本不会留下痕迹。</li>
</ul>
</li>
<li><p>利用HTTP协议的特性进行拒绝服务攻击的一些构思<br>​       <strong>服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求</strong>（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。<br>而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。<br>19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务<br>方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。</p>
</li>
<li><p>Http指纹识别技术<br>   Http指纹识别的原理大致上也是相同的：<strong>记录不同服务器对Http协议执行中的微小差别进行识别.</strong>Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别.<br>​      要让服务器返回不同的Banner信息的设置是很简单的,像Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。、</p>
<p>常用测试请求：<br>1：HEAD/Http/1.0发送基本的Http请求<br>2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求<br>3：GET/Http/3.0发送一个非法版本的Http协议请求<br>4：GET/JUNK/1.0发送一个不正确规格的Http协议请求</p>
</li>
<li><p>为了提高用户使用浏览器时的性能，现代浏览器还支持<strong>并发的访问方式</strong>，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。</p>
<p>HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关<strong>会话控制、丰富的内容协商</strong>等方式的支持，来提供<br>更高效率的连接。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/07/03/http/" data-id="cj4r0q9cw000crotp4hso23p4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-uni" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/01/uni/" class="article-date">
  <time class="post-time" datetime="2017-07-01T13:53:15.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/01/uni/">正则表达式</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/07/01/uni/" class="leancloud_visitors" data-flag-title="正则表达式">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>序言：正则表达式这个东西，挺重要也挺麻烦的，所以今天就在网上搜集整理了一波，方便用到的时候使用，嘻嘻，喜欢的拿走不谢哦(●’◡’●)</p>
<h4 id="一、基本知识："><a href="#一、基本知识：" class="headerlink" title="一、基本知识："></a>一、基本知识：</h4><ol>
<li>/正则表达式主体/修饰符(可选)</li>
<li>i 执行对大小写不敏感的匹配。</li>
<li>g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</li>
<li>m 执行多行匹配。</li>
<li>[abc] 查找方括号之间的任何字符。</li>
<li>[0-9] 查找任何从 0 至 9 的数字</li>
<li>(x|y) 查找任何以 | 分隔的选项。</li>
<li>\d 查找数字。</li>
<li>\s 查找空白字符</li>
<li>\b 匹配单词边界。</li>
<li>\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。</li>
<li>n+ 匹配任何包含至少一个 <em>n</em> 的字符串。</li>
<li>n<em> 匹配任何包含零个或多个 </em>n* 的字符串。</li>
<li>n? 匹配任何包含零个或一个 <em>n</em> 的字符串。</li>
</ol>
<h4 id="二、实例："><a href="#二、实例：" class="headerlink" title="二、实例："></a>二、实例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/*是否带有小数*/</div><div class="line">function    isDecimal(strValue )  &#123;  </div><div class="line">   var  objRegExp= /^\d+\.\d+$/;</div><div class="line">   return  objRegExp.test(strValue);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">/*校验是否中文名称组成 */</div><div class="line">function ischina(str) &#123;</div><div class="line">	var reg=/^[\u4E00-\u9FA5]&#123;2,4&#125;$/;   /*定义验证表达式*/</div><div class="line">	return reg.test(str);     /*进行验证*/</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*校验是否全由8位数字组成 */</div><div class="line">function isStudentNo(str) &#123;</div><div class="line">	var reg=/^[0-9]&#123;8&#125;$/;   /*定义验证表达式*/</div><div class="line">	return reg.test(str);     /*进行验证*/</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*校验电话码格式 */</div><div class="line">function isTelCode(str) &#123;</div><div class="line">	var reg= /^((0\d&#123;2,3&#125;-\d&#123;7,8&#125;)|(1[3584]\d&#123;9&#125;))$/;</div><div class="line">	return reg.test(str);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*校验邮件地址是否合法 */</div><div class="line">function IsEmail(str) &#123;</div><div class="line">	var reg=/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/;</div><div class="line">	return reg.test(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="三、热心网友整理的："><a href="#三、热心网友整理的：" class="headerlink" title="三、热心网友整理的："></a>三、热心网友整理的：</h4><p>只能输入数字：”^[0-9]<em>$”。<br>只能输入n位的数字：”^\d{n}$”。<br>只能输入至少n位的数字：”^\d{n,}$”。<br>只能输入m~n位的数字：。”^\d{m,n}$”<br>只能输入零和非零开头的数字：”^(0|[1-9][0-9]</em>)$”。<br>只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。<br>只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。<br>只能输入非零的正整数：”^+?[1-9][0-9]<em>$”。<br>只能输入非零的负整数：”^-[1-9][]0-9”</em>$。<br>只能输入长度为3的字符：”^.{3}$”。<br>只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。<br>只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。<br>只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。<br>只能输入由数字和26个英文字母组成的字符串：”^[A-Za-z0-9]+$”。<br>只能输入由数字、26个英文字母或者下划线组成的字符串：”^\w+$”。<br>验证用户密码：”^[a-zA-Z]\w{5,17}$”正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。<br>验证是否含有^%&amp;’,;=?$\”等字符：”[^%&amp;’,;=?$\x22]+”。<br>只能输入汉字：”^[\u4e00-\u9fa5]{0,}$” </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/07/01/uni/" data-id="cj4r0q9dc000jrotpyv4ueduj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-biji" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/01/biji/" class="article-date">
  <time class="post-time" datetime="2017-07-01T12:25:42.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/01/biji/">biji</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/07/01/biji/" class="leancloud_visitors" data-flag-title="biji">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>序言：我这个银啊，最大的缺点局势爱忘，越简单越容易忘，所以我要把所有最基础的东西都给整理一遍，嘻嘻，别觉得我智障哦(⊙o⊙)。开始啦，都是我的小笔记，大家可以滤过，和我一样脑子经常忘带的可以多进来逛逛(●’◡’●)。</p>
<h4 id="1-插入css样式表："><a href="#1-插入css样式表：" class="headerlink" title="1. 插入css样式表："></a>1. 插入css样式表：</h4><ul>
<li>外部样式表：<strong><link rel="stylesheet" type="text/css" href="###.css"></strong></li>
<li>内部样式表：<strong><style></style></strong></li>
<li>内联样式：例：<strong><p style=" color:sienna;margin-left:20px"></p></strong></li>
<li>优先级：内联样式&gt;内部样式&gt;外部样式</li>
</ul>
<h4 id="2-插入JS脚本："><a href="#2-插入JS脚本：" class="headerlink" title="2.插入JS脚本："></a>2.插入JS脚本：</h4><ul>
<li>放在内部(head或body中)的JS脚本：<strong><script></script></strong></li>
<li>外部的JS脚本：<strong><script src="###.js"></script></strong></li>
<li>JS脚本放置技巧：<ol>
<li>如果把javascript放在head里的话，则先被解析,但这时候body还没有解析。（常规html结构都是head在前，body在后）如果head的js代码是<strong>需要传</strong>入一个<strong>参</strong>数（在body中调用该方法时，才会传入参数），并需调用该参数进行一系列的操作，那么这时候肯定就会报错，因为函数该参数未定义（undefined）。</li>
<li>，从JavaScript对页面<strong>下载性能方向</strong>考虑：由于脚本会阻塞其他资源的下载（如图片等）和页面渲染，直到脚本全部下载并执行完成后，页面的渲染才会继续，因此推荐将所有的<script>标签尽可能放到<body>标签的底部，以尽量减少对整个页面下载的影响。</li>
<li><strong><script type="text/javascript" defer="defer"></strong>defer延迟页面加载，但是只有ie支持defer属性</li>
</ol>
</li>
</ul>
<h4 id="3-JS调试："><a href="#3-JS调试：" class="headerlink" title="3.JS调试："></a>3.JS调试：</h4><ol>
<li>浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</li>
<li>console.log()方法：<ul>
<li>a = 5;<br>b = 6;<br>c = a + b;<br>console.log(c);</li>
</ul>
</li>
<li>设置断点:<strong>debugger</strong> 关键字用于停止执行 JavaScript，并调用调试函数。<ul>
<li>var x = 15 * 5;<br>debugger;<br>document.getElementbyId(“demo”).innerHTML = x;</li>
</ul>
</li>
<li>主要浏览器的调试工具：<ul>
<li>chrome浏览器：<ul>
<li>在工具中选择开发者工具</li>
<li>最后选择Console</li>
</ul>
</li>
<li>Firefox浏览器：<ul>
<li>访问页面:<br><a href="http://www.getfirebug.com。">http://www.getfirebug.com。</a></li>
<li>按照说明 :<br>安装 Firebug。</li>
</ul>
</li>
<li>Internet Explorer浏览器：<ul>
<li>在工具中选择开发者工具。</li>
<li>最后，选择 Console</li>
</ul>
</li>
<li>Opara:<ul>
<li>打开浏览器。</li>
<li>Opera 的内置调试工具为 Dragonfly，详细说明可访问页面:<br><a href="http://www.opera.com/dragonfly/。">http://www.opera.com/dragonfly/。</a></li>
</ul>
</li>
<li>Safari:<ul>
<li>打开浏览器。</li>
<li>右击鼠标，选择检查元素。</li>
<li>在底部弹出的窗口中选择”控制台”。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="4-JS变量提升："><a href="#4-JS变量提升：" class="headerlink" title="4.JS变量提升："></a>4.JS变量提升：</h4><ul>
<li><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p>
</li>
<li><p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
</li>
<li><p>JavaScript 只有声明的变量会提升，初始化的不会。</p>
<ul>
<li><p>var x = 5; // 初始化 x</p>
<p>elem = document.getElementById(“demo”); // 查找元素<br>elem.innerHTML = x + “ “ + y;           // 显示 x 和 y</p>
<p>var y = 7; // 初始化 y</p>
<p>//输出5和undefined</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-eval函数："><a href="#5-eval函数：" class="headerlink" title="5.eval函数："></a>5.eval函数：</h4><ul>
<li><p>eval()只有一个参数。如果<strong>传入的参数不是字符串</strong>，它直接<strong>返回这个函数</strong>。如果参数<strong>是字符串</strong>，它会把字符串当成JavaScript代码进行编译，如果<strong>编译失败</strong>者<strong>抛出</strong>一个语法错误<strong>异常</strong>。如果<strong>编译成功</strong>，则开始<strong>执行这一段代码</strong>，并返回字符串中的最后一个表达式会或语句的值，如果<strong>最后一个表达式或语句没有值</strong>，则最终<strong>返回undefined</strong>。如果字符串<strong>抛出一个异常</strong>，这个异常将把该调用<strong>传递给eval()</strong>。</p>
</li>
<li><p>如果一个函数定义了一个局部变量x，然后<strong>调用eval(“x”)</strong>，它会<strong>返回局部变量的值</strong>。如果它调用eval(“x=1”)，它会改变局部变量的值。如果函数<strong>调用了eval(“var y=2;”)</strong>,它<strong>声明了一个新的局部变量y</strong>，同样地，一个函数可以通过如下代码声明一个局部变量：</p>
<p>eval(“function f(){return x+1;}”);</p>
</li>
<li><p>全局eval:但当脚本定义了eval的一个别名，且用另一个名称调用它时，会直接改变全局变量的值</p>
</li>
<li><p>在严格模式下，eval执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的变量或函数</p>
</li>
<li><p>严格模式将“eval”列为保留字，这让eval（）更像一个运算符。不能用一个别名覆盖eval（）函数。并且变量名，函数名。函数参数或者异常捕获的参数都不能取名为eval。</p>
</li>
</ul>
<h4 id="6-JS严格模式："><a href="#6-JS严格模式：" class="headerlink" title="6.JS严格模式："></a>6.JS严格模式：</h4><ul>
<li>严格模式通过在脚本或函数的<strong>头部添加 “use strict”</strong> 表达式来声明。</li>
<li>不允许使用未声明的变量：</li>
<li>不允许删除变量或对象。</li>
<li>不允许删除函数。</li>
<li>不允许变量重名:</li>
<li>不允许使用八进制:</li>
<li>不允许使用转义字符:</li>
<li>不允许对只读属性赋值:</li>
<li>不允许对一个使用getter方法读取的属性进行赋值</li>
<li>不允许删除一个不允许删除的属性：</li>
<li>变量名不能使用 “eval” 字符串:</li>
<li>变量名不能使用 “arguments” 字符串:</li>
<li>由于一些安全原因，在作用域 eval() 创建的变量不能被调用：</li>
<li>禁止this关键字指向全局对象。</li>
</ul>
<h4 id="7-javascript使用误区："><a href="#7-javascript使用误区：" class="headerlink" title="7.javascript使用误区："></a>7.javascript使用误区：</h4><ul>
<li><p><strong>if</strong> 条件语句返回 <strong>true</strong> (不是我们预期的)因为条件语句执行为 x 赋值 10，10 为 true</p>
<ul>
<li>var x = 0;</li>
<li>if (x == 10)</li>
</ul>
</li>
<li><p><strong>if</strong> 条件语句返回 <strong>false</strong> (不是我们预期的)因为条件语句执行为 x 赋值 0，0 为 false:</p>
<ul>
<li>var x = 0;</li>
<li>if (x = 0)</li>
</ul>
</li>
<li><p>在常规的比较中，数据类型是被忽略的，以下 if 条件语句返回 true：</p>
<ul>
<li>var x = 10;</li>
<li>var y = “10”;</li>
<li>if (x == y)</li>
</ul>
</li>
<li><p>在严格的比较运算中，=== 为恒等计算符，同时检查表达式的值与类型，以下 if 条件语句返回 false：</p>
<ul>
<li>var x = 10;<br>var y = “10”;<br>if (x === y)</li>
<li>switch 语句会使用恒等计算符(===)进行比较:<ul>
<li>以下实例由于类型不一致不会执行 alert 弹窗：</li>
<li>var x = 10;</li>
<li>switch(x) {case “10”: alert(“Hello”);}</li>
</ul>
</li>
</ul>
</li>
<li><p>加法连接注意事项：</p>
<ul>
<li><strong>加法</strong>是两个<strong>数字</strong>相加。</li>
<li><strong>连接</strong>是两个<strong>字符串</strong>连接。</li>
<li>var x = 10 + 5;          // x 的结果为 15</li>
<li>var x = 10 + “5”;        // x 的结果为 “105”</li>
</ul>
</li>
<li><p>JavaScript 中的所有数据都是以 64 位<strong>浮点型数据(float)</strong> 来存储。</p>
<p>所有的编程语言，包括 JavaScript，对浮点型数据的精确度都很难确定：</p>
<ul>
<li>var x = 0.1;</li>
<li>var y = 0.2;</li>
<li>var z = x + y            // z 的结果为 0.3</li>
<li>if (z == 0.3)            // 返回 false</li>
<li>为解决以上问题，可以用整数的乘除法来解决：</li>
<li>var z = (x <em> 10 + y </em> 10) / 10;       // z 的结果为 0.3</li>
</ul>
</li>
<li><p>javascript字符串分行：</p>
<ul>
<li>JavaScript 允许我们在字符串中使用断行语句:</li>
<li>但是，在字符串中直接<strong>使用回车换行</strong>是<strong>会报错</strong>的：</li>
<li>字符串断行需要使用反斜杠(\).</li>
</ul>
</li>
<li><p>javaScript <strong>不支持使用名字来索引数组</strong>，<strong>只允许使用数字索引</strong>。在 JavaScript 中, <strong>对象</strong> 使用 <strong>名字作为索引</strong>。如果你<strong>使用名字作为索引</strong>，当访问数组时，JavaScript 会把数组<strong>重新定义为标准对象</strong>。</p>
</li>
<li><p>在 JavaScript 中, <strong>null</strong> 用于对象, <strong>undefined</strong> 用于变量，属性和方法。</p>
<p>对象只有被定义才有可能为 null，否则为 undefined。</p>
</li>
</ul>
<h4 id="8-JSON"><a href="#8-JSON" class="headerlink" title="8.JSON"></a>8.JSON</h4><ul>
<li>JSON 是用于存储和传输数据的格式。</li>
<li>JSON 是一种轻量级的数据交换格式。</li>
<li>JSON是独立的语言 </li>
<li>JSON 易于理解。</li>
<li>实例：<ul>
<li>{“sites”:[<br>​    {“name”:”Runoob”, “url”:”www.runoob.com”},<br>​    {“name”:”Google”, “url”:”www.google.com”},<br>​    {“name”:”Taobao”, “url”:”www.taobao.com”}<br>]}</li>
</ul>
</li>
</ul>
<h4 id="9-javascript-void-0"><a href="#9-javascript-void-0" class="headerlink" title="9.javascript:void(0)"></a>9.javascript:void(0)</h4><ul>
<li>javascript:void(0), 仅仅表示一个死链接</li>
</ul>
<h4 id="10-Javascript代码规范"><a href="#10-Javascript代码规范" class="headerlink" title="10.Javascript代码规范"></a>10.Javascript代码规范</h4><ul>
<li>全局变量为大写 (<strong>UPPERCASE </strong>)</li>
<li>常量 (如 PI) 为大写 (<strong>UPPERCASE </strong>)</li>
</ul>
<ul>
<li>变量名推荐使用驼峰法来命名(<strong>camelCase</strong>)</li>
<li>通常运算符 ( = + - * / ) 前后需要添加空格</li>
<li>通常使用 4 个空格符号来缩进代码块：</li>
<li>一条语句通常以分号作为结束符。</li>
<li><ul>
<li>将左花括号放在第一行的结尾。</li>
<li>左花括号前添加一空格。</li>
<li>将右花括号独立放在一行。</li>
<li>不要以分号结束一个复杂的声明。</li>
</ul>
</li>
<li>对象定义的规则:<ul>
<li>将左花括号与类名放在同一行。</li>
<li>冒号与属性值间有个空格。</li>
<li>字符串使用双引号，数字不需要。</li>
<li>最后一个属性-值对后面不要添加逗号。</li>
<li>将右花括号独立放在一行，并以分号作为结束符号</li>
</ul>
</li>
<li>每行字符小于数 80 个</li>
<li>HTML 与 JavaScript 尽量使用相同的命名规则。</li>
</ul>
</script></li></ol></li></ul>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/07/01/biji/" data-id="cj4r0q9cb0005rotpmtua11v2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-JSmanul" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/01/JSmanul/" class="article-date">
  <time class="post-time" datetime="2017-07-01T07:25:32.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/01/JSmanul/">JS手册</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/07/01/JSmanul/" class="leancloud_visitors" data-flag-title="JS手册">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、序言："><a href="#一、序言：" class="headerlink" title="一、序言："></a>一、序言：</h3><ol>
<li>在开始之前我们先谈谈什么叫做<strong>大前端</strong>吧。所谓“大前端”，顾名思义应该是比“小前端”承担更多职责。传统上，Web应用可分为前端（在浏览器中执行的部分）和后端（在服务器中执行的部分）。前端工程师的职责是以Web技术（HTML、CSS、JavaScript、DOM、Ajax等）实现基于浏览器的用户界面。以相衔接的工作来说，是将视觉设计师、交互设计师的工作成果转化为可运行代码，完成的代码则要交付给后端工程师，进一步完成代码集成、测试、发布和部署。这样一种体系可能存在不少问题，具体就不展开了。“大前端”则是将传统上归于后端的服务器脚本和模板划归到前端。</li>
<li>我学东西比较急，通常都是把逻辑搞懂了，然后语法这方面就靠查看手册，今天就好好复习一下吧。</li>
</ol>
<h3 id="二、进入主题"><a href="#二、进入主题" class="headerlink" title="二、进入主题"></a>二、进入主题</h3><ol>
<li><p>定义变量:var</p>
</li>
<li><p>定义函数function()</p>
</li>
<li><p>输出内容：document.write();</p>
</li>
<li><p>警告弹出：alert()</p>
</li>
<li><p>确认：confirm()</p>
</li>
<li><p>消息对话框：prompt()</p>
</li>
<li><p>打开新窗口：window.open(“<a href="http://#######&quot;,&quot;打开方式&quot;,&quot;width=#&quot;,&quot;height=#&quot;,&quot;top=#&quot;,&quot;left=#" target="_blank" rel="external">http://#######&quot;,&quot;打开方式&quot;,&quot;width=#&quot;,&quot;height=#&quot;,&quot;top=#&quot;,&quot;left=#</a>“)</p>
<p>打开方式：_blank,_self,_top;</p>
</li>
<li><p>关闭窗口：obj.close();</p>
</li>
<li><p>通过id获取元素：document.getElementById(“id”);</p>
</li>
<li><p>获取或者替换HTML元素的内容：obj.innerHTML;</p>
</li>
<li><p>改变HTML样式：Obj.style.property = new style;例：mychar.style.color = “red”;</p>
</li>
<li><p>显示和隐藏：obj.style.display = block(显示)/none(隐藏);</p>
</li>
<li><p>控制类名:obj.className = classname       例：p1.classname = “two”</p>
</li>
<li><p>数组定义:var myarr = new Array(),myarr[0] = 80; myarr = new array(11,22,33);</p>
<p>使用一个新索引，即可为数组增加新元素</p>
</li>
<li><p>数组长度:myarray.length;</p>
</li>
<li><p>二维数组：</p>
<ul>
<li>var myarr=new Array();  //先声明一维 for(var i=0;i&lt;2;i++){   //一维长度为2   myarr[i]=new Array();  //再声明二维    for(var j=0;j&lt;3;j++){   //二维长度为3   myarr[i][j]=i+j;   // 赋值，每个数组元素的值为i+j   } }</li>
</ul>
</li>
<li><p>事件：</p>
<ul>
<li>鼠标单击事件：onclick = “function()”</li>
<li>鼠标经过事件：onmouseover = “function()”</li>
<li>鼠标离开事件：onmouseout = “function()”</li>
<li>光标聚焦事件：onfocus = “function()”</li>
<li>失焦事件：onblur = “function()”</li>
<li>内容选中事件：onselect = “function()”</li>
<li>文本框内容改变事件：onchange = “function()”</li>
<li>加载事件：onload = “function()”</li>
<li>卸载事件：onunload = “function()”</li>
</ul>
</li>
<li><p>内置对象：</p>
<ul>
<li>访问对象属性的方法：objName.propertyName;</li>
<li>访问对象的方法：objName.methodName()</li>
<li>日期对象；var Udate = new Date(); /  var Udate = new Date(2012,10,1);<ul>
<li>返回/设置日期：get/setDate()</li>
<li>返回/设置年份（四位数）：get/setFullYear()</li>
<li>返回/设置年份：get/setYear()</li>
<li>返回/设置月份：get/setMonth()</li>
<li>返回/设置小时(24小时):get/setHours()</li>
<li>返回/设置分钟：get/setMinutes()</li>
<li>返回/设置秒钟：get/setSeconds()</li>
<li>返回/设置时间(毫秒为单位)：get/setTime()</li>
</ul>
</li>
<li>字符串对象:<ul>
<li>定义：var mystr = “I love Javasript!”</li>
<li>访问长度：mystr.length</li>
<li>访问方法：mystr.function()</li>
<li>返回指定位置字符串:mystr.charAt()</li>
<li>返回指定字符串值首次出现的位置：mystr.indexof(“o”,5)</li>
<li>字符串分割：<ul>
<li>mystr.split(“se”,”limit”)——se代表以什么分割，如：”_或者.”当se为空字符串””时将分割每一个单词</li>
<li>limit是要分割的字符数，可省略；</li>
</ul>
</li>
<li>字符串提取：mystr.substr(start,stop);</li>
</ul>
</li>
<li>Math对象：<ul>
<li>Math.PI</li>
<li>向上取整：Math.ceil(x)</li>
<li>向下取整：Math.floor(x)</li>
<li>四舍五入：Math.round(x)</li>
<li>随机数：Math.random()</li>
</ul>
</li>
<li>数组对象：<ul>
<li>数组连接：arr1.contact(arr2,arr3)</li>
<li>指定分隔符连接数组元素：arr.join(“分隔符”)——arr.join(“.”)</li>
<li>颠倒数组：arr.reverse()</li>
<li>选定元素：arr.slice(start,end)</li>
<li>数组排序：arr.sort();</li>
</ul>
</li>
</ul>
</li>
<li><p>浏览器对象：</p>
<ul>
<li>计时器：<ul>
<li>设定计时器每隔指定时间调用一次函数：setInterval(“function()”,time)</li>
<li>取消计时器：clearinterval(id_ofsetinterval)</li>
<li>载入后延迟指定时间去执行一次代码(仅一次)：setTimeout(“代码”,time)</li>
<li>取消计时器：clearTimeout(id_ofsetTimeout)</li>
</ul>
</li>
<li>history对象：<ul>
<li>history中url数量：window.history.length</li>
<li>history中的前一个url：window.history.back()</li>
<li>history中的下一个url：window.history.forward()</li>
<li>history中的某个具体页面：window.history.go()</li>
</ul>
</li>
<li>location对象：<ul>
<li>设置或返回以#开头的URＬ：window.location.hash</li>
<li>设置或返回主机名和当前URL端口号：window.location.host</li>
<li>设置或返回当前URL的主机名：window.location.hostname</li>
<li>设置或返回完整的URL：window.location.href</li>
<li>设置或返回当前URL的端口号：window.location.port</li>
<li>设置或返回当前URL的协议：window.location.protocol</li>
<li>设置或返回从问号（？）开始的URL（查询部分）:window.location.search</li>
<li>加载新的文档：window.location.assign()</li>
<li>重新加载文档：window.location.reload()</li>
<li>用新的文档代替当前文档：window.location.repalce()</li>
</ul>
</li>
<li>Navigator对象：<ul>
<li>浏览器代码名的字符串表示：navigator.appCodeName</li>
<li>返回浏览器名称：navigator.appname</li>
<li>返回浏览器的平台和版本信息：navigator.appVersion</li>
<li>返回浏览器的操作系统平台：navigator.platform</li>
<li>返回由客户发送的user.agent头部的值</li>
</ul>
</li>
<li>Screen对象：<ul>
<li>窗口可使用的屏幕高度，单位像素：window.screen.availHeight</li>
<li>窗口可使用的屏幕宽度，单位像素：window.screen.availWidth</li>
<li>用户浏览器表示的颜色位数：window.screen.colorDepth</li>
<li>屏幕的高度，单位像素：window.screen.height</li>
<li>屏幕的宽度，单位像素：window.screen.width</li>
</ul>
</li>
</ul>
</li>
<li><p>DOM对象：</p>
<ul>
<li><p>返回带有指定名称节点的对象组合：document.getElementsByName(name);</p>
</li>
<li><p>返回带有指定标签名节点的对象组合：document.getElementsByTagName(Tagname)</p>
</li>
<li><p>通过元素节点的<strong>属性</strong>名称获取属性的值：elementNode.getAttribute(name)</p>
</li>
<li><p>通过元素节点的属性名称设置属性值（增加）：elementNode.setAttribute(name,value)</p>
</li>
<li><p>节点属性：</p>
<ul>
<li>节点名称：node.nodeName</li>
<li>节点的值：node.nodeValue</li>
<li>节点的类型：node.nodeType</li>
</ul>
</li>
<li><p>访问子节点：elementNode.childNodes</p>
</li>
<li><p>访问子节点的第一项和最后一项：node.firstchild——node.lastchild</p>
</li>
<li><p>访问父节点：elementNode.parentNode</p>
</li>
<li><p>访问兄弟节点：node.nextSibling</p>
</li>
<li><p>插入节点(最后一个子节点之后)：node.appendChild(newnode)</p>
</li>
<li><p>在已有子节点之前插入一个新的子节点：node.insertBefore(newnode,node)</p>
</li>
<li><p>删除节点：node.removeChild(node)</p>
</li>
<li><p>替换元素节点：node.removeChild(newnode,oldnode)</p>
</li>
<li><p>创建元素节点：document.createElement(tagName)</p>
</li>
<li><p>创建文本节点：document.createTextNode(data)</p>
</li>
<li><p>浏览器窗口可视区域大小：var w = document.documentElement.clientWidth||document.body.clientWidth,</p>
<p>var h = document.documentElement.clientHeight||document.body.clientHeight</p>
</li>
<li><p>获取网页内容高度和宽度：</p>
<p>var w = document.documentElement.scrollWidth||document.body.scrollWidth</p>
<p>var h = document.documentElement.scrollHeight||document.body.scrollHeight</p>
</li>
<li><p>网页尺寸：offsetHeight = clientHeight+滚动条+边框</p>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/07/01/JSmanul/" data-id="cj4r0q9bf0000rotptko6z7p5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-tuofeng" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/30/tuofeng/" class="article-date">
  <time class="post-time" datetime="2017-06-30T02:25:32.000Z" itemprop="datePublished">
    <span class="post-month">6月</span><br/>
    <span class="post-day">30</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/30/tuofeng/">常见的几种编程命名方式</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/06/30/tuofeng/" class="leancloud_visitors" data-flag-title="常见的几种编程命名方式">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、匈牙利命名法-Hungaarian"><a href="#一、匈牙利命名法-Hungaarian" class="headerlink" title="一、匈牙利命名法[Hungaarian]"></a>一、匈牙利命名法[Hungaarian]</h3><ul>
<li>广泛应用于象 Microsoft Windows 这样的环境中。</li>
<li>通过在变量前面加上相应的小写字母的符号标识作为前缀， 标识出变量的作用域， 类型等</li>
<li>匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是 首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。</li>
<li>m_lpszStr</li>
</ul>
<h3 id="二、驼峰命名法-camelCase"><a href="#二、驼峰命名法-camelCase" class="headerlink" title="二、驼峰命名法[camelCase]"></a>二、驼峰命名法[camelCase]</h3><ul>
<li>是指混合使用大小写字母来构成变量和函数 的名字</li>
<li>函数名中的每一个逻辑断点都有一个大写字母来标记myName</li>
<li>函数名中的每一个逻辑断点都有一个下划线来标记 print_employee_paychecks</li>
</ul>
<h3 id="三、帕斯卡命名法"><a href="#三、帕斯卡命名法" class="headerlink" title="三、帕斯卡命名法"></a>三、帕斯卡命名法</h3><ul>
<li><p>与骆驼命名法类似。只不过骆驼命名法是首字母小写，而帕斯卡命名法是首字母大写  UserName;</p>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/06/30/tuofeng/" data-id="cj4r0q9dc000irotp93j3rizx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-compitible" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/29/compitible/" class="article-date">
  <time class="post-time" datetime="2017-06-29T06:23:32.000Z" itemprop="datePublished">
    <span class="post-month">6月</span><br/>
    <span class="post-day">29</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/29/compitible/">浏览器(内核，渲染，兼容)</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/06/29/compitible/" class="leancloud_visitors" data-flag-title="浏览器(内核，渲染，兼容)">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、各大浏览器市场占有率"><a href="#一、各大浏览器市场占有率" class="headerlink" title="一、各大浏览器市场占有率"></a>一、各大浏览器市场占有率</h3><p><img src="/2017/06/29/compitible/ddd.png" alt="Alt rr"></p>
<h3 id="二、各浏览器的内核"><a href="#二、各浏览器的内核" class="headerlink" title="二、各浏览器的内核"></a>二、各浏览器的内核</h3><ol>
<li><strong>什么是浏览器内核？</strong><ul>
<li>浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li>
</ul>
</li>
<li><strong>常见的浏览器内核</strong><ul>
<li>Trident内核——IE</li>
<li>Gecko内核——Mozilla FireFox（火狐浏览器）</li>
<li>Webkit内核——chrome(谷歌)、Safari</li>
<li>Presto内核——Opera(欧朋)</li>
</ul>
</li>
<li><strong>css3对不同浏览器的内核识别码</strong><ul>
<li>-ms-对应ie</li>
<li>-moz-对应Mozilla FireFox(火狐)</li>
<li>-webkit-对应Chrome(谷歌)</li>
<li>-o-对应Opara(欧朋)</li>
</ul>
</li>
</ol>
<h3 id="三、解决浏览器兼容性问题"><a href="#三、解决浏览器兼容性问题" class="headerlink" title="三、解决浏览器兼容性问题"></a>三、解决浏览器兼容性问题</h3><ol>
<li><p><strong>浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同</strong></p>
<p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p>
<p>碰到频率:100%</p>
<p>解决方案：CSS里    *{margin:0;padding:0;}</p>
<p>备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</p>
</li>
<li><p><strong>浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大</strong></p>
<p>问题症状:常见症状是IE6中后面的一块被顶到下一行</p>
<p>碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）</p>
<p>解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性</p>
<p>备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。</p>
</li>
<li><p><strong>浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度</strong></p>
<p>问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</p>
<p>碰到频率：60%</p>
<p>解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</p>
<p>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。</p>
</li>
<li><p><strong>浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug</strong></p>
<p>问题症状：IE6里的间距比超过设置的间距</p>
<p>碰到几率：20%</p>
<p>解决方案：在display:block;后面加入display:inline;display:table;</p>
<p>备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。</p>
</li>
<li><p><strong>浏览器兼容问题五：图片默认有间距</strong></p>
<p>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p>
<p>碰到几率：20%</p>
<p>解决方案：使用float属性为img布局</p>
<p>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）</p>
</li>
<li><p><strong>浏览器兼容问题六：标签最低高度设置min-height不兼容</strong></p>
<p>问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</p>
<p>碰到几率：5%</p>
<p>解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}</p>
<p>备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/06/29/compitible/" data-id="cj4r0q9ct0009rotpjh8m1iyh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-face" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/28/face/" class="article-date">
  <time class="post-time" datetime="2017-06-28T08:06:41.000Z" itemprop="datePublished">
    <span class="post-month">6月</span><br/>
    <span class="post-day">28</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/face/">面对对象——三大基本特征&amp;&amp;五项原则</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/06/28/face/" class="leancloud_visitors" data-flag-title="面对对象——三大基本特征&amp;&amp;五项原则">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、三大特性"><a href="#一、三大特性" class="headerlink" title="一、三大特性"></a>一、三大特性</h2><ol>
<li><strong>封装</strong>：把客观事物封装成抽象的类，并且类可以把自己的<strong>数据和方法</strong>只让可信的类或者对象操作，对不可信的进行信息隐藏</li>
<li><strong>继承</strong>：可以让某个类型的对象<strong>获得另一个类型的对象的属性</strong>的方法。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。           </li>
<li><strong>多态</strong>：指一个类实例的相同方法在<strong>不同情形有不同表现形式</strong>。多态机制使具有不同内部结构的对象可以共享相同的外部接口</li>
</ol>
<h2 id="二、五大基本原则"><a href="#二、五大基本原则" class="headerlink" title="二、五大基本原则"></a>二、五大基本原则</h2><ol>
<li>单一职责原则SRP(Single Responsibility Principle)是指一个类的功能要单一，不能包罗万象</li>
<li>开放封闭原则OCP(Open－Close Principle)<br>一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。</li>
<li>替换原则(the Liskov Substitution Principle LSP)<br>子类应当可以替换父类并出现在父类能够出现的任何地方。</li>
<li>依赖原则(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。</li>
<li>接口分离原则(the Interface Segregation Principle ISP)<br>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/06/28/face/" data-id="cj4r0q9cb0007rotp9ueky3ax" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-nullandun" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/23/nullandun/" class="article-date">
  <time class="post-time" datetime="2017-06-23T12:56:51.000Z" itemprop="datePublished">
    <span class="post-month">6月</span><br/>
    <span class="post-day">23</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/23/nullandun/">null、undefined和&quot; &quot;区别</a>
    </h1>
  

        <div>
          
          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2017/06/23/nullandun/" class="leancloud_visitors" data-flag-title="null、undefined和&quot; &quot;区别">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>undefined：表示变量声明未初始化的<strong>值</strong></li>
<li>null：表示尚未存在对象，一个空对象指针</li>
<li>” ”：空字符串</li>
<li>实例: <ul>
<li>null == undefined(true)</li>
<li>null === undefined(false)</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://boominy.github.io/2017/06/23/nullandun/" data-id="cj4r0q9cw000erotpzshpvnqp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">SexMonkey</h1>
    <h2 class="blog-subtitle">null</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="/images/haimian.jpg">
    <h2 class="author">BooMiny</h2>
    <h3 class="description">女程序猿也可以性感和可耐o(*￣▽￣*)ブ</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>25</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/BooMiny" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>新浪微博</h2>
      
        <a class="hvr-bounce-in" href="http://weibo.com/5323027182/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" title="BooMiny">
          BooMiny
        </a>
      
    </div>
  </div>
</div>

  
    
    <div class="widget-wrap">
    <h3 class="widget-title">浏览数目</h3>
    <div class="widget">
      <ul class="popularlist">
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2016 - 2017 BooMiny<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>




  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("7jLaPEaNjAdu9N26yLk8sdyf-gzGzoHsz", "0qQ0z6bI5p5dnwgK9Aqxx0a6");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.article-title').length > 1) {
        showTime(Counter);
      }
    });
  </script>





!--page counter part-->
<script>
function addCount (Counter) {
        url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query=new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results){
            if(results.length>0)
            {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            }
            else
            {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter){
                    //alert('New object created');
                    },
                    error: function(newcounter,error){
                    alert('Failed to create');
                    }
                    });
            }
        },
        error: function(error){
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function(){
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1)
       addCount(Counter);
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results){
                for(var i=0;i<results.length;i++)    
                {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error){
            alert("Error:"+error.code+" "+error.message);
        }
        }
    )
    });
  </div>
</body>
</html>